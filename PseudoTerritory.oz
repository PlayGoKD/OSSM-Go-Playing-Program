functor

import JAZTools System SimpleBoard Browser 
export FindTerritoryArctan FindTerritoryManhat FindTerritoryCluster

define
   %  This file provides three functions to analyze Psuedo Territories on the board.
   %
   %  The PlayBoard offers methods that call these functions and maintain a cache of the arrays
   %    generated. It will generally be more efficient to use the PlayBoard methods rather than this.
   %
   %  A Psuedo Territory is a section of the board that is roughly surrounded by one player.
   %    It doesn't need to be completely surrounded.
   %
   %  Psuedo Territories are found by first creating an array saying which player controls each
   %    space of the board, or if its not controlled. Control means having sufficient influence
   %    on the space.
   %  Then it finds all vacant regions of the board that are completely surrounded by one player
   %    and the wall, and turns that area into controlled by that player.
   %
   %  This file offers two different ways to find Psuedo Territories, using Arctan Influence
   %    and using Manhattan Distance Influence.
   %
   %  FindTerritoryArctan and FindTerritoryManhat both return an array corresponding to
   %     the board whose values are:
   %                             1  =>  black controlled
   %                             0  =>  not controlled
   %                             ~1 =>  white controlled
   %
   %  FindTerritoryArctan will say that a player controls any space that they have Arctan
   %     Influence greater than the  ArctanControlRequirement, or if it is in a region completely
   %     surrounded by spaces controlled by that player or the wall.
   %  
   %  FindTerritoryManhat will say that a player controls any space that they have any Manhattan
   %     Influence for that player, or if it is in a region completely surrounded by spaces 
   %     controlled by that player or the wall.
   %
   %  FindTerritoryCluster takes an array generated by either FindTerritoryArctan or FindTerritoryManhat
   %      and a space on the board, and then it returns a record containing:
   %                           Color
   %                           Spaces   (Stones + Vacants)
   %                           Stones   (All stones in territory)
   %                           Vacants  (All vacants in territory)
   %                           Border   (All spaces that are adjacent to an uncontrolled or enemy controlled)
   
   
   ArctanControlRequirement = 0.4

   fun{FindTerritoryArctan Board}
      {Walk  Board fun{$ R C} {Board getArctanInfl(R C $)}.2>ArctanControlRequirement end
	               fun{$ R C} {Board getArctanInfl(R C $)}.2<~1.0*ArctanControlRequirement end}
   end
   
   fun{FindTerritoryManhat Board}
      {Walk Board fun{$ R C} 
	                  X = {Board getInfluence(R C $)}
				  in
				      X.1==black andthen X.2>0.0 end
							
	              fun{$ R C} 
	                  X = {Board getInfluence(R C $)}
			 	  in
				      X.1==white andthen X.2>0.0 end   }
   end
   
   fun{FindController Board Ary R C}
      if {IsOnTheBoard Board R C} then
         case {Get Ary R*{Board size($)}+C}
	     of 1 then black
	     [] ~1 then white
	     else vacant end
	  else
	     border
	  end
   end
   
   fun{FindTerritoryCluster Board Ary R C}   
        %not tested yet
      Col = {FindController Board Ary R C}
	  AllSpaces = {NewCell nil}
	  Stones = {NewCell nil}
	  Vacants = {NewCell nil}
	  Border = {NewCell nil}
	  
      proc{Recurs R C}
	     if {IsOnTheBoard Board R C} andthen {Not {List.member (R#C) @AllSpaces}} andthen
		    ((Col==black andthen {FindController Board Ary R C}==black)
		        orelse (Col==white andthen {FindController Board Ary R C}==white)
				orelse (Col==vacant andthen {FindController Board Ary R C}==vacant)) then
				
			if {Board get(R C $)}\=vacant then
			   Stones:= (R#C)|@Stones
			else
			   Vacants := (R#C)|@Vacants
			end
		    if ({FindController Board Ary R+1 C}\=Col andthen {FindController Board Ary R+1 C}\=border)
                   	 orelse ({FindController Board Ary R-1 C}\=Col andthen {FindController Board Ary R-1 C}\=border) 
					 orelse ({FindController Board Ary R C+1}\=Col andthen {FindController Board Ary R C+1}\=border) 
					 orelse ({FindController Board Ary R C-1}\=Col andthen {FindController Board Ary R C-1}\=border) then
				Border := (R#C)|@Border
		    end
			AllSpaces := (R#C)|@AllSpaces
			{Recurs R+1 C}
			{Recurs R-1 C}
			{Recurs R C+1}
			{Recurs R C-1}
		 end
	  end
   in
      {Recurs R C}
      territoryCluster(color:Col  spaces:@AllSpaces  stones:@Stones  vacants:@Vacants  border:@Border)
   end
   
   fun{Walk Board BlackReq WhiteReq} 
      Size = {Board size($)}
      Ary = {NewArray Size+1 (Size+1)*Size+1 0}
	  Seen
   in
   
      % Finding all location that meet Black or White requirement, and 
	  %     then setting them to 1 or ~1 respectively
	  
      for R in 1..{Board size($)} do
	     for C in 1..{Board size($)} do
		    if {Board get(R C $)}==vacant then
		       if {BlackReq R C} then
			      {Put Ary R*{Board size($)}+C 1}
		       elseif {WhiteReq R C} then
			      {Put Ary R*{Board size($)}+C ~1}
			   end
			elseif {Board get(R C $)}==black then
			   {Put Ary R*{Board size($)}+C 1}
			else
			   {Put Ary R*{Board size($)}+C ~1}
			end
		 end
	  end
	  
	  % Finding all regions of not controlled space that is completely surrounded by one color's
	  %   controlled space and the wall, and then setting them to 1 or ~1 respectively
	  
	  Seen = {NewCell nil}
	  for R in 1..{Board size($)} do
	     for C in 1..{Board size($)} do
		    if {Get Ary R*{Board size($)}+C}==0 andthen {Not {Member R#C @Seen}} then
			   Color = {NewCell unknown}
			   CurGroup = {NewCell nil}
			in
			   {Recurs R C Board Ary Color CurGroup}
			   for (R#C) in @CurGroup do
			      if @Color == black then
				     {Put Ary R*{Board size($)}+C 1}
				  elseif @Color == white then
				     {Put Ary R*{Board size($)}+C ~1}
				  end
			   end
			   Seen := {Append @CurGroup @Seen}
			end
		 end
	  end
	  Ary
   end
   
   proc{Recurs R C Board Ary Color CurGroup}
      if {IsOnTheBoard Board R C} then
         if {Get Ary R*{Board size($)}+C}==0 andthen {Not {Member R#C @CurGroup}} then
		    CurGroup := (R#C)|@CurGroup
		    {Recurs R+1 C Board Ary Color CurGroup}
			{Recurs R-1 C Board Ary Color CurGroup}
			{Recurs R C+1 Board Ary Color CurGroup}
		    {Recurs R C-1 Board Ary Color CurGroup}
	     elseif {Get Ary R*{Board size($)}+C}==1 then
	        if @Color == unknown then
			   Color := black
			elseif @Color == black then
			   skip
			elseif @Color == white then
			   Color := conflict
			end
		 elseif {Get Ary R*{Board size($)}+C}==~1 then
	        if @Color == unknown then
			   Color := white
			elseif @Color == white then
			   skip
			elseif @Color == black then
			   Color := conflict
			end
	     end
	  end
   end
   
   fun{IsOnTheBoard Board R C}
      L = {Board size($)}+1
   in
      {And {And R>0 C>0} {And R<L C<L}}
   end
end